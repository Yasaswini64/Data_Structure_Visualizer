<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Binary Search Tree Visualization</title>

<style>
body {
  margin: 0;
  overflow: hidden;
  background: radial-gradient(circle at top, #1a1a1a, #000);
  font-family: "Segoe UI", sans-serif;
}

/* ===== BACK BUTTON ===== */
.back-btn {
  position: fixed;
  top: 18px;
  left: 18px;
  font-size: 34px;
  color: #00eaff;
  text-decoration: none;
  font-weight: bold;
  padding: 6px 12px;
  border-radius: 50%;
  z-index: 100;
}

.back-btn:hover {
  background: rgba(0, 234, 255, 0.15);
}

/* ===== HEADER ===== */
header {
  position: fixed;
  top: 0;
  width: 100%;
  height: 90px;
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(10px);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 50;
}

header .title {
  font-size: 28px;
  font-weight: 700;
  color: #00eaff;
}

header .subtitle {
  font-size: 14px;
  color: #b5f7ff;
  margin-top: 4px;
}

/* ===== CONTROL PANEL ===== */
#panel {
  position: fixed;
  top: 120px;
  left: 20px;
  width: 280px;
  background: rgba(255, 255, 255, 0.08);
  backdrop-filter: blur(10px);
  border-radius: 14px;
  padding: 16px;
  color: #fff;
  z-index: 40;
  box-shadow: 0 0 30px rgba(0, 234, 255, 0.15);
}

input, button {
  width: 100%;
  margin-top: 8px;
  padding: 8px;
  border-radius: 8px;
  border: none;
}

input {
  background: rgba(0, 0, 0, 0.6);
  color: #00eaff;
}

button {
  font-weight: bold;
  background: linear-gradient(135deg, #00eaff, #0077ff);
  cursor: pointer;
}

button:hover {
  opacity: 0.9;
}

#status {
  margin-top: 12px;
  padding: 8px;
  text-align: center;
  font-weight: bold;
  background: rgba(0, 0, 0, 0.5);
  color: #00eaff;
}
</style>
</head>

<body>

<!-- Back Button -->
<a href="trees.html" class="back-btn">‚Üê</a>

<!-- Header -->
<header>
  <div class="title">Binary Search Tree</div>
  <div class="subtitle">Insert, search, and delete in a BST</div>
</header>

<!-- Control Panel -->
<div id="panel">
  <input id="valueInput" placeholder="Enter value" />
  <button onclick="insertBST()">Insert</button>
  <button onclick="searchBST()">Search</button>
  <button onclick="deleteBST()">Delete</button>
  <button onclick="resetTree()">Reset</button>
  <div id="status">Status: Ready</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
/* ---------- SCENE ---------- */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.set(0, 18, 30);
camera.lookAt(0, 0, 0);

/* ---------- RENDERER ---------- */
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.domElement.style.position = "fixed";
renderer.domElement.style.top = "0";
renderer.domElement.style.left = "0";
renderer.domElement.style.zIndex = "1";
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff, 1));
scene.add(new THREE.DirectionalLight(0xffffff, 1));

/* ---------- DATA ---------- */
class Node {
  constructor(val) {
    this.val = val;
    this.left = null;
    this.right = null;
    this.mesh = null;
  }
}

let root = null;
const group = new THREE.Group();
scene.add(group);

/* ---------- STATUS ---------- */
function status(msg, color = "#00eaff") {
  const s = document.getElementById("status");
  s.innerText = msg;
  s.style.color = color;
}

/* ---------- LABEL ---------- */
function createLabel(text) {
  const canvas = document.createElement("canvas");
  canvas.width = 256;
  canvas.height = 256;
  const ctx = canvas.getContext("2d");

  ctx.fillStyle = "#ffffff";
  ctx.font = "bold 130px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(text, 128, 128);

  const texture = new THREE.CanvasTexture(canvas);
  const sprite = new THREE.Sprite(
    new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false })
  );
  sprite.scale.set(1.8, 1.8, 1);
  return sprite;
}

/* ---------- NODE ---------- */
function createNodeMesh(val) {
  const mesh = new THREE.Mesh(
    new THREE.SphereGeometry(1.4, 42, 42),
    new THREE.MeshStandardMaterial({ color: 0x0077ff })
  );
  mesh.add(createLabel(val.toString()));
  return mesh;
}

/* ---------- DRAW TREE ---------- */
function drawTree() {
  group.clear();
  if (!root) return;

  const queue = [[root, 0, 0]];
  const pos = new Map();

  while (queue.length) {
    const [node, depth, x] = queue.shift();
    pos.set(node, { x, y: 6 - depth * 3 });

    const gap = 10 / (depth + 2);
    if (node.left) queue.push([node.left, depth + 1, x - gap]);
    if (node.right) queue.push([node.right, depth + 1, x + gap]);
  }

  function edge(a, b) {
    const pa = pos.get(a);
    const pb = pos.get(b);
    const geo = new THREE.BufferGeometry().setFromPoints([
      new THREE.Vector3(pa.x, pa.y, 0),
      new THREE.Vector3(pb.x, pb.y, 0),
    ]);
    group.add(new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0xffffff })));
  }

  function render(node) {
    if (!node) return;
    const p = pos.get(node);
    node.mesh = createNodeMesh(node.val);
    node.mesh.position.set(p.x, p.y, 0);
    group.add(node.mesh);

    if (node.left) edge(node, node.left);
    if (node.right) edge(node, node.right);

    render(node.left);
    render(node.right);
  }

  render(root);
}

/* ---------- BST OPERATIONS ---------- */
function insertNode(node, val) {
  if (!node) return new Node(val);
  if (val < node.val) node.left = insertNode(node.left, val);
  else if (val > node.val) node.right = insertNode(node.right, val);
  return node;
}

function insertBST() {
  const v = parseInt(valueInput.value);
  if (isNaN(v)) return;
  root = insertNode(root, v);
  drawTree();
  status("Inserted " + v);
}

function searchNode(node, val) {
  if (!node) return false;
  node.mesh.material.color.set(0xffaa00);
  if (node.val === val) {
    node.mesh.material.color.set(0x00ff00);
    return true;
  }
  return val < node.val ? searchNode(node.left, val) : searchNode(node.right, val);
}

function searchBST() {
  const v = parseInt(valueInput.value);
  if (isNaN(v)) return;
  drawTree();
  const found = searchNode(root, v);
  status(found ? "Found " + v : "Not Found", found ? "#00ff00" : "#ff4444");
}

function minValue(node) {
  while (node.left) node = node.left;
  return node;
}

function deleteNode(node, val) {
  if (!node) return null;
  if (val < node.val) node.left = deleteNode(node.left, val);
  else if (val > node.val) node.right = deleteNode(node.right, val);
  else {
    if (!node.left) return node.right;
    if (!node.right) return node.left;
    const t = minValue(node.right);
    node.val = t.val;
    node.right = deleteNode(node.right, t.val);
  }
  return node;
}

function deleteBST() {
  const v = parseInt(valueInput.value);
  if (isNaN(v)) return;
  root = deleteNode(root, v);
  drawTree();
  status("Deleted " + v, "#ff4444");
}

function resetTree() {
  root = null;
  group.clear();
  status("Tree Reset");
}

/* ---------- RENDER ---------- */
function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
