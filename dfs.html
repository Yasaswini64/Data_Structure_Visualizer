<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>DFS with Stack Visualization</title>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: radial-gradient(circle at top, #1a1a1a, #000);
      font-family: "Segoe UI", sans-serif;
    }

    /* ===== BACK BUTTON ===== */
    .back-btn {
      position: fixed;
      top: 18px;
      left: 18px;
      font-size: 34px;
      color: #00eaff;
      text-decoration: none;
      font-weight: bold;
      padding: 6px 12px;
      border-radius: 50%;
      z-index: 100;
    }

    .back-btn:hover {
      background: rgba(0, 234, 255, 0.15);
    }

    header {
      position: absolute;
      top: 0;
      width: 100%;
      text-align: center;
      padding: 14px;
      font-size: 26px;
      font-weight: 700;
      color: #00eaff;
      background: rgba(0, 0, 0, 0.5);
      z-index: 50;
    }

    /* LEFT PANEL */
    #panel {
      position: absolute;
      top: 80px;
      left: 20px;
      width: 320px;
      background: rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(10px);
      border-radius: 14px;
      padding: 16px;
      color: #fff;
      z-index: 40;
    }

    /* RIGHT STACK PANEL */
    #stackPanel {
      position: absolute;
      top: 80px;
      right: 20px;
      width: 220px;
      background: rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(10px);
      border-radius: 14px;
      padding: 16px;
      color: #00eaff;
      z-index: 40;
    }

    #stack {
      margin-top: 10px;
      display: flex;
      flex-direction: column-reverse;
    }

    .stackItem {
      padding: 8px;
      margin: 4px 0;
      text-align: center;
      font-weight: bold;
      border-radius: 8px;
      background: linear-gradient(135deg, #00eaff, #0077ff);
      color: #000;
    }

    input,
    button,
    textarea {
      width: 100%;
      margin-top: 8px;
      padding: 8px;
      border-radius: 8px;
      border: none;
    }

    textarea {
      height: 80px;
      resize: none;
      background: rgba(0, 0, 0, 0.6);
      color: #00eaff;
    }

    input {
      background: rgba(0, 0, 0, 0.6);
      color: #00eaff;
    }

    button {
      font-weight: bold;
      background: linear-gradient(135deg, #00eaff, #0077ff);
      cursor: pointer;
    }

    #result {
      margin-top: 12px;
      padding: 8px;
      background: rgba(0, 0, 0, 0.6);
      color: #00ff88;
      font-weight: bold;
    }
  </style>
</head>

<body>

<!-- Back Button -->
<a href="graphs.html" class="back-btn">←</a>

<header>DEPTH FIRST SEARCH (GRAPH) – STACK VISUALIZATION</header>

<div id="panel">
  <input id="nodesInput" placeholder="Nodes (e.g. A,B,C,D)" />
  <textarea id="edgesInput" placeholder="Edges (e.g. A-B,B-C,A-D)"></textarea>
  <input id="sourceInput" placeholder="Source Node (e.g. A)" />
  <button onclick="generateGraph()">Generate Graph</button>
  <button onclick="startDFS()">▶ Start DFS</button>
  <div id="result">Traversal: —</div>
</div>

<div id="stackPanel">
  <h3>STACK</h3>
  <div id="stack"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
/* ---------- SCENE ---------- */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.set(0, 12, 26);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.domElement.style.position = "fixed";
renderer.domElement.style.top = "0";
renderer.domElement.style.left = "0";
renderer.domElement.style.zIndex = "1";
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff, 0.9));
scene.add(new THREE.DirectionalLight(0xffffff, 1));

/* ---------- DATA ---------- */
let graph = {}, nodes = {}, dfsSteps = [], timer = null;
let visualStack = [];
const group = new THREE.Group();
scene.add(group);

/* ---------- LABEL ---------- */
function createLabel(text) {
  const canvas = document.createElement("canvas");
  canvas.width = 256;
  canvas.height = 256;
  const ctx = canvas.getContext("2d");
  ctx.fillStyle = "#fff";
  ctx.font = "bold 90px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(text, 128, 128);

  const texture = new THREE.CanvasTexture(canvas);
  const sprite = new THREE.Sprite(
    new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false })
  );
  sprite.scale.set(1.2, 1.2, 1);
  return sprite;
}

/* ---------- NODE ---------- */
function createNode(name, x, y) {
  const mesh = new THREE.Mesh(
    new THREE.SphereGeometry(0.9, 32, 32),
    new THREE.MeshStandardMaterial({ color: 0x0077ff })
  );
  mesh.position.set(x, y, 0);
  mesh.add(createLabel(name));
  nodes[name] = mesh;
  group.add(mesh);
}

/* ---------- EDGE ---------- */
function drawEdge(a, b) {
  const geo = new THREE.BufferGeometry().setFromPoints([
    nodes[a].position,
    nodes[b].position,
  ]);
  group.add(new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0xffffff })));
}

/* ---------- GRAPH ---------- */
function generateGraph() {
  group.clear();
  nodes = {};
  graph = {};
  dfsSteps = [];
  visualStack = [];
  updateStack();
  clearInterval(timer);

  const list = nodesInput.value.split(",");
  const angle = (2 * Math.PI) / list.length;
  const radius = 8;

  list.forEach((n, i) => {
    const name = n.trim();
    createNode(name, Math.cos(i * angle) * radius, Math.sin(i * angle) * radius);
    graph[name] = [];
  });

  edgesInput.value.split(",").forEach((e) => {
    const [u, v] = e.split("-").map(x => x.trim());
    if (graph[u] && graph[v]) {
      graph[u].push(v);
      graph[v].push(u);
      drawEdge(u, v);
    }
  });
}

/* ---------- STACK UI ---------- */
function updateStack() {
  const s = document.getElementById("stack");
  s.innerHTML = "";
  visualStack.forEach(v => {
    const div = document.createElement("div");
    div.className = "stackItem";
    div.innerText = v;
    s.appendChild(div);
  });
}

/* ---------- DFS ---------- */
function startDFS() {
  dfsSteps = [];
  visualStack = [];
  updateStack();
  clearInterval(timer);

  const src = sourceInput.value.trim();
  if (!graph[src]) return;

  const visited = new Set();

  function dfs(u) {
    dfsSteps.push({ type: "push", node: u });
    visited.add(u);

    graph[u].forEach(v => {
      if (!visited.has(v)) dfs(v);
    });

    dfsSteps.push({ type: "pop" });
  }

  dfs(src);

  let i = 0, order = [];
  timer = setInterval(() => {
    if (i >= dfsSteps.length) {
      clearInterval(timer);
      result.innerText = "Traversal: " + order.join(" → ");
      return;
    }

    const step = dfsSteps[i++];
    if (step.type === "push") {
      visualStack.push(step.node);
      order.push(step.node);
      nodes[step.node].material.color.set(0x00ff00);
    } else {
      visualStack.pop();
    }
    updateStack();
  }, 900);
}

/* ---------- RENDER ---------- */
function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
