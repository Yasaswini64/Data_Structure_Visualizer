<!-- ONLY UI COLORS CHANGED ‚Äî LOGIC SAME -->
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Insertion Sort</title>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #ffffff;
        font-family: "Segoe UI", sans-serif;
        color: #000;
      }

      /* BACK BUTTON */
      .back-btn {
        position: fixed;
        top: 18px;
        left: 18px;
        font-size: 32px;
        color: #0077ff;
        text-decoration: none;
        font-weight: bold;
        z-index: 100;
      }

      /* HEADER */
      header {
        position: fixed;
        top: 0;
        width: 100%;
        height: 90px;
        background: #f5f7fa;
        border-bottom: 1px solid #ddd;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 50;
      }

      header .title {
        font-size: 28px;
        color: #0077ff;
        font-weight: bold;
      }
      header .subtitle {
        font-size: 14px;
        color: #555;
      }

      /* PANEL */
      #panel {
        position: fixed;
        top: 120px;
        left: 20px;
        width: 270px;
        background: #ffffff;
        border-radius: 14px;
        padding: 16px;
        color: #000;
        border: 1px solid #ddd;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.08);
        z-index: 40;
      }

      input,
      button {
        width: 100%;
        margin-top: 8px;
        padding: 8px;
        border-radius: 8px;
        border: 1px solid #ccc;
      }

      input {
        background: #f9f9f9;
        color: #000;
      }

      button {
        background: linear-gradient(135deg, #0077ff, #00aaff);
        color: #fff;
        font-weight: bold;
        cursor: pointer;
      }

      #status {
        margin-top: 12px;
        padding: 8px;
        text-align: center;
        background: #f1f3f6;
        color: #0077ff;
        border-radius: 8px;
        font-weight: bold;
      }

      /* Complexity table */
      #complexity {
        position: fixed;
        bottom: 18px;
        right: 18px;
        background: #ffffff;
        color: #000;
        padding: 12px;
        border-radius: 10px;
        z-index: 100;
        font-family: Consolas, monospace;
        font-size: 13px;
        min-width: 220px;
        border: 1px solid #ddd;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.08);
      }

      #complexity th {
        color: #0077ff;
      }
      #complexity .active {
        background: rgba(0, 119, 255, 0.15);
        color: #0077ff;
        font-weight: bold;
      }
    </style>
  </head>

  <body>
    <a href="index.html" class="back-btn">‚Üê</a>

    <header>
      <div class="title">Insertion Sort</div>
      <div class="subtitle">Step-by-step execution</div>
    </header>

    <div id="panel">
      <input id="arrayInput" value="5,3,8,4,2,7" />

      <button onclick="generate()">Generate</button>
      <button onclick="start()">‚ñ∂ Start</button>
      <button onclick="pause()">‚è∏ Pause</button>
      <button onclick="reset()">üîÑ Reset</button>

      <!-- SPEED -->
      <input id="speed" type="range" min="1" max="100" value="50" />
      <div id="status">Status: Ready</div>

      <div
        style="
          margin-top: 14px;
          background: white;
          color: black;
          padding: 10px;
          border-radius: 10px;
          font-family: Consolas;
        "
      >
        <div id="l1">for (i = 1; i &lt; n; i++)</div>
        <div id="l2">&nbsp;&nbsp;key = arr[i]</div>
        <div id="l3">&nbsp;&nbsp;j = i - 1</div>
        <div id="l4">
          &nbsp;&nbsp;while (j &gt;= 0 &amp;&amp; arr[j] &gt; key)
        </div>
        <div id="l5">&nbsp;&nbsp;&nbsp;&nbsp;arr[j + 1] = arr[j]</div>
        <div id="l6">&nbsp;&nbsp;&nbsp;&nbsp;j--</div>
        <div id="l7">&nbsp;&nbsp;arr[j + 1] = key</div>
      </div>
    </div>

    <!-- Complexity table in bottom-right -->
    <div id="complexity" aria-hidden="false">
      <table>
        <thead>
          <tr>
            <th>Case</th>
            <th>Time</th>
          </tr>
        </thead>
        <tbody>
          <tr id="bestRow">
            <td>Best</td>
            <td>O(n)</td>
          </tr>
          <tr id="avgRow">
            <td>Average</td>
            <td>O(n¬≤)</td>
          </tr>
          <tr id="worstRow">
            <td>Worst</td>
            <td>O(n¬≤)</td>
          </tr>
          <tr id="spaceRow" class="neutral">
            <td>Space</td>
            <td>O(1)</td>
          </tr>
        </tbody>
      </table>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

    <script>
      /* ---------- THREE ---------- */
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);
      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        1000,
      );
      camera.position.set(0, 10, 18);
      camera.lookAt(0, 5, 0);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.domElement.style.position = "fixed";
      renderer.domElement.style.zIndex = "1";
      document.body.appendChild(renderer.domElement);

      scene.add(new THREE.AmbientLight(0xffffff, 0.7));
      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(5, 10, 5);
      scene.add(light);

      const group = new THREE.Group();
      scene.add(group);

      /* ---------- DATA ---------- */
      let array = [],
        bars = [];
      let i = 1,
        j = 0,
        keyBar = null,
        keyVal = 0,
        phase = 0;
      let running = false,
        lastTime = 0;

      /* track whether initial input is already sorted */
      let initiallySorted = false;

      /* ---------- ROTATION ---------- */
      let mouseDown = false,
        lastX = 0,
        lastY = 0,
        allowRotation = true;
      const panel = document.getElementById("panel");

      panel.addEventListener("mouseenter", () => (allowRotation = false));
      panel.addEventListener("mouseleave", () => (allowRotation = true));

      window.addEventListener("mousedown", (e) => {
        if (!allowRotation) return;
        mouseDown = true;
        lastX = e.clientX;
        lastY = e.clientY;
      });
      window.addEventListener("mouseup", () => (mouseDown = false));
      window.addEventListener("mousemove", (e) => {
        if (!mouseDown || !allowRotation) return;
        group.rotation.y += (e.clientX - lastX) * 0.005;
        group.rotation.x += (e.clientY - lastY) * 0.003;
        lastX = e.clientX;
        lastY = e.clientY;
      });

      /* ---------- HIGHLIGHT ---------- */
      function highlight(id) {
        ["l1", "l2", "l3", "l4", "l5", "l6", "l7"].forEach((x) => {
          const el = document.getElementById(x);
          if (el) {
            el.style.background = "white";
            el.style.fontWeight = "normal";
          }
        });
        if (id) {
          const el = document.getElementById(id);
          if (el) {
            el.style.background = "#cceeff";
            el.style.fontWeight = "bold";
          }
        }
      }

      /* ---------- LABEL ---------- */
      function makeLabel(text) {
        const c = document.createElement("canvas");
        c.width = 256;
        c.height = 128;
        const ctx = c.getContext("2d");
        ctx.fillStyle = "#0077ff";
        ctx.font = "bold 64px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, 128, 64);
        const t = new THREE.CanvasTexture(c);
        const s = new THREE.Sprite(new THREE.SpriteMaterial({ map: t }));
        s.scale.set(2.2, 1.1, 1);
        return s;
      }

      /* ---------- CREATE BARS ---------- */
      function createBars() {
        group.clear();
        bars = [];
        i = 1;
        j = 0;
        phase = 0;
        keyBar = null;
        const spacing = 1.5;
        const max = Math.max(...array, 1);

        array.forEach((v, idx) => {
          const h = (v / max) * 8 + 0.5;
          const bar = new THREE.Mesh(
            new THREE.BoxGeometry(1, h, 1),
            new THREE.MeshStandardMaterial({ color: 0x0077ff }),
          );
          bar.position.set(
            idx * spacing - ((array.length - 1) * spacing) / 2,
            h / 2,
            0,
          );

          const lb = makeLabel(v.toString());
          lb.position.set(bar.position.x, -1.1, 0);
          bar.userData = { value: v, label: lb };

          group.add(bar, lb);
          bars.push(bar);
        });
      }

      /* ---------- COMPLEXITY UI ---------- */
      function clearComplexityHighlight() {
        ["bestRow", "avgRow", "worstRow"].forEach((id) => {
          const el = document.getElementById(id);
          if (el) el.classList.remove("active");
        });
      }
      function updateComplexity(state) {
        // state: 'ready' | 'running' | 'completed'
        clearComplexityHighlight();
        const n = array.length;
        if (state === "ready") {
          // best-case only if already sorted (insertion sort O(n))
          if (initiallySorted && n > 0)
            document.getElementById("bestRow").classList.add("active");
          else document.getElementById("avgRow").classList.add("active");
          return;
        }
        if (state === "running") {
          // while running show representative average (O(n¬≤))
          document.getElementById("avgRow").classList.add("active");
          return;
        }
        if (state === "completed") {
          if (initiallySorted)
            document.getElementById("bestRow").classList.add("active");
          else document.getElementById("worstRow").classList.add("active");
          return;
        }
      }

      /* ---------- GENERATE ---------- */
      function generate() {
        running = false;
        array = document
          .getElementById("arrayInput")
          .value.split(",")
          .map(Number);
        // detect if initially sorted (non-decreasing)
        initiallySorted =
          array.length <= 1 ||
          array.every((v, idx) => idx === 0 || array[idx] >= array[idx - 1]);
        createBars();
        highlight(null);
        document.getElementById("status").innerText = "Status: Ready";
        updateComplexity("ready");
      }

      /* ---------- STEP ---------- */
      function step() {
        if (i >= array.length) {
          document.getElementById("status").innerText = "Sorting Completed";
          bars.forEach((b) => b.material.color.set(0x00ff00));
          running = false;
          updateComplexity("completed");
          return;
        }

        if (phase === 0) {
          highlight("l1");
          phase = 1;
        } else if (phase === 1) {
          highlight("l2");
          keyVal = array[i];
          keyBar = bars[i];
          keyBar.material.color.set(0xff00ff);
          phase = 2;
        } else if (phase === 2) {
          highlight("l3");
          j = i - 1;
          phase = 3;
        } else if (phase === 3) {
          highlight("l4");
          if (j >= 0 && array[j] > keyVal) phase = 4;
          else phase = 6;
        } else if (phase === 4) {
          highlight("l5");
          array[j + 1] = array[j];
          bars[j + 1] = bars[j];
          bars[j + 1].position.x += 1.5;
          bars[j + 1].userData.label.position.x += 1.5;
          phase = 5;
        } else if (phase === 5) {
          highlight("l6");
          j--;
          phase = 3;
        } else if (phase === 6) {
          highlight("l7");
          array[j + 1] = keyVal;
          bars[j + 1] = keyBar;
          const x = (j + 1) * 1.5 - ((array.length - 1) * 1.5) / 2;
          keyBar.position.x = x;
          keyBar.userData.label.position.x = x;
          keyBar.material.color.set(0x00ff00);
          i++;
          phase = 0;
        }

        // update complexity display while running
        updateComplexity("running");
      }

      /* ---------- CONTROLS ---------- */
      function start() {
        running = true;
        updateComplexity("running");
      }
      function pause() {
        running = false;
        updateComplexity("ready");
      }
      function reset() {
        running = false;
        generate();
      }

      /* ---------- LOOP ---------- */
      function animate(time) {
        requestAnimationFrame(animate);

        if (running) {
          const speed = document.getElementById("speed").value;
          const delay = 2100 - speed * 20;
          if (time - lastTime > delay) {
            step();
            lastTime = time;
          }
        }

        renderer.render(scene, camera);
      }
      animate();

      /* ---------- RESIZE ---------- */
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      generate();
    </script>
  </body>
</html>
