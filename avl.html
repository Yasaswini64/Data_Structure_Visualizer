<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>AVL Tree Visualization</title>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: radial-gradient(circle at top, #1a1a1a, #000);
        font-family: "Segoe UI", sans-serif;
      }

      .back-btn {
        position: fixed;
        top: 18px;
        left: 18px;
        font-size: 34px;
        color: #00eaff;
        text-decoration: none;
        font-weight: bold;
        padding: 6px 12px;
        border-radius: 50%;
        z-index: 100;
      }

      header {
        position: fixed;
        top: 0;
        width: 100%;
        height: 90px;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(10px);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 50;
      }

      header .title {
        font-size: 28px;
        font-weight: 700;
        color: #00eaff;
      }

      header .subtitle {
        font-size: 14px;
        color: #b5f7ff;
        margin-top: 4px;
      }

      #panel {
        position: fixed;
        top: 120px;
        left: 20px;
        width: 280px;
        background: rgba(255, 255, 255, 0.08);
        backdrop-filter: blur(10px);
        border-radius: 14px;
        padding: 16px;
        color: #fff;
        z-index: 40;
      }

      input,
      button {
        width: 100%;
        margin-top: 8px;
        padding: 8px;
        border-radius: 8px;
        border: none;
      }

      input {
        background: rgba(0, 0, 0, 0.6);
        color: #00eaff;
      }

      button {
        font-weight: bold;
        background: linear-gradient(135deg, #00eaff, #0077ff);
        cursor: pointer;
      }

      #status {
        margin-top: 12px;
        padding: 8px;
        text-align: center;
        font-weight: bold;
        background: rgba(0, 0, 0, 0.5);
        color: #00eaff;
      }
    </style>
  </head>

  <body>
    <a href="trees.html" class="back-btn">‚Üê</a>

    <header>
      <div class="title">AVL Tree</div>
      <div class="subtitle">
        Self-balancing binary search tree visualization
      </div>
    </header>

    <div id="panel">
      <input id="valueInput" placeholder="Enter value" />
      <button onclick="insertAVL()">Insert</button>
      <button onclick="deleteAVL()">Delete</button>
      <button onclick="searchAVL()">Search</button>
      <button onclick="resetTree()">Reset</button>
      <div id="status">Status: Ready</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

    <script>
      // SCENE
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x111111);

      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        1000,
      );
      camera.position.set(0, 14, 26);
      camera.lookAt(0, 6, 0);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.domElement.style.position = "fixed";
      document.body.appendChild(renderer.domElement);

      scene.add(new THREE.AmbientLight(0xffffff, 0.9));
      scene.add(new THREE.DirectionalLight(0xffffff, 1));

      // AVL NODE
      class Node {
        constructor(val) {
          this.val = val;
          this.left = null;
          this.right = null;
          this.height = 1;
          this.mesh = null;
        }
      }

      let root = null;
      const group = new THREE.Group();
      scene.add(group);

      // STATUS
      function status(msg, color = "#00eaff") {
        const s = document.getElementById("status");
        s.innerText = msg;
        s.style.color = color;
      }

      // LABEL
      function createLabel(text) {
        const canvas = document.createElement("canvas");
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext("2d");

        ctx.fillStyle = "#ffffff";
        ctx.font = "bold 150px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, 256, 256);

        const texture = new THREE.CanvasTexture(canvas);
        const sprite = new THREE.Sprite(
          new THREE.SpriteMaterial({ map: texture, transparent: true }),
        );
        sprite.scale.set(2.2, 2.2, 1);
        return sprite;
      }

      function createNodeMesh(val) {
        const node = new THREE.Mesh(
          new THREE.SphereGeometry(1.3, 42, 42),
          new THREE.MeshStandardMaterial({ color: 0x0077ff }),
        );
        node.add(createLabel(val.toString()));
        return node;
      }

      // AVL HELPERS
      const h = (n) => (n ? n.height : 0);
      const balance = (n) => (n ? h(n.left) - h(n.right) : 0);

      // ROTATIONS
      function rightRotate(y) {
        const x = y.left;
        const T2 = x.right;
        x.right = y;
        y.left = T2;
        y.height = 1 + Math.max(h(y.left), h(y.right));
        x.height = 1 + Math.max(h(x.left), h(x.right));
        return x;
      }

      function leftRotate(x) {
        const y = x.right;
        const T2 = y.left;
        y.left = x;
        x.right = T2;
        x.height = 1 + Math.max(h(x.left), h(x.right));
        y.height = 1 + Math.max(h(y.left), h(y.right));
        return y;
      }

      // INSERT
      function insert(node, val) {
        if (!node) return new Node(val);
        if (val < node.val) node.left = insert(node.left, val);
        else if (val > node.val) node.right = insert(node.right, val);
        else return node;

        node.height = 1 + Math.max(h(node.left), h(node.right));
        const b = balance(node);

        if (b > 1 && val < node.left.val) return rightRotate(node);
        if (b < -1 && val > node.right.val) return leftRotate(node);
        if (b > 1 && val > node.left.val) {
          node.left = leftRotate(node.left);
          return rightRotate(node);
        }
        if (b < -1 && val < node.right.val) {
          node.right = rightRotate(node.right);
          return leftRotate(node);
        }

        return node;
      }

      // DELETE (FIXED)
      function minValueNode(node) {
        while (node.left) node = node.left;
        return node;
      }

      function deleteNode(root, key) {
        if (!root) return root;

        if (key < root.val) root.left = deleteNode(root.left, key);
        else if (key > root.val) root.right = deleteNode(root.right, key);
        else {
          if (!root.left || !root.right) {
            const temp = root.left || root.right;
            if (!temp) return null;
            root = temp;
          } else {
            const temp = minValueNode(root.right);
            root.val = temp.val;
            root.right = deleteNode(root.right, temp.val);
          }
        }

        root.height = 1 + Math.max(h(root.left), h(root.right));
        const b = balance(root);

        if (b > 1 && balance(root.left) >= 0) return rightRotate(root);
        if (b > 1 && balance(root.left) < 0) {
          root.left = leftRotate(root.left);
          return rightRotate(root);
        }
        if (b < -1 && balance(root.right) <= 0) return leftRotate(root);
        if (b < -1 && balance(root.right) > 0) {
          root.right = rightRotate(root.right);
          return leftRotate(root);
        }

        return root;
      }

      // DRAW
      function drawTree() {
        group.clear();
        if (!root) return;

        const q = [[root, 0, 0]];
        const pos = new Map();

        while (q.length) {
          const [n, d, x] = q.shift();
          pos.set(n, { x, y: 7 - d * 2.8 });
          if (n.left) q.push([n.left, d + 1, x - 6 / (d + 2)]);
          if (n.right) q.push([n.right, d + 1, x + 6 / (d + 2)]);
        }

        function render(n) {
          if (!n) return;
          const p = pos.get(n);
          n.mesh = createNodeMesh(n.val);
          n.mesh.position.set(p.x, p.y, 0);
          group.add(n.mesh);

          if (n.left) render(n.left);
          if (n.right) render(n.right);
        }

        render(root);
      }

      // UI
      function insertAVL() {
        const v = parseInt(valueInput.value);
        if (isNaN(v)) return;
        root = insert(root, v);
        drawTree();
        status("Inserted " + v);
      }

      function deleteAVL() {
        const v = parseInt(valueInput.value);
        if (isNaN(v)) return;
        root = deleteNode(root, v);
        drawTree();
        status("Deleted " + v, "#ff4444");
      }

      function searchAVL() {
        const v = parseInt(valueInput.value);
        if (isNaN(v)) return;
        drawTree();
        let n = root;
        while (n) {
          n.mesh.material.color.set(0xffaa00);
          if (n.val === v) {
            n.mesh.material.color.set(0x00ff00);
            status("Found " + v, "#00ff00");
            return;
          }
          n = v < n.val ? n.left : n.right;
        }
        status("Not Found", "#ff4444");
      }

      function resetTree() {
        root = null;
        group.clear();
        status("Tree Reset");
      }

      // RENDER LOOP
      function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
      }
      animate();
    </script>
  </body>
</html>
