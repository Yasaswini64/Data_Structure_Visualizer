<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>AVL Tree Visualization</title>

<style>
body {
  margin: 0;
  overflow: hidden;
  background: radial-gradient(circle at top, #1a1a1a, #000);
  font-family: "Segoe UI", sans-serif;
}

/* ===== BACK BUTTON ===== */
.back-btn {
  position: fixed;
  top: 18px;
  left: 18px;
  font-size: 34px;
  color: #00eaff;
  text-decoration: none;
  font-weight: bold;
  padding: 6px 12px;
  border-radius: 50%;
  z-index: 100;
}

.back-btn:hover {
  background: rgba(0, 234, 255, 0.15);
}

/* ===== HEADER ===== */
header {
  position: fixed;
  top: 0;
  width: 100%;
  height: 90px;
  background: rgba(0, 0, 0, 0.7);
  backdrop-filter: blur(10px);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 50;
}

header .title {
  font-size: 28px;
  font-weight: 700;
  color: #00eaff;
}

header .subtitle {
  font-size: 14px;
  color: #b5f7ff;
  margin-top: 4px;
}

/* ===== CONTROL PANEL ===== */
#panel {
  position: fixed;
  top: 120px;
  left: 20px;
  width: 280px;
  background: rgba(255, 255, 255, 0.08);
  backdrop-filter: blur(10px);
  border-radius: 14px;
  padding: 16px;
  color: #fff;
  z-index: 40;
  box-shadow: 0 0 30px rgba(0, 234, 255, 0.15);
}

input, button {
  width: 100%;
  margin-top: 8px;
  padding: 8px;
  border-radius: 8px;
  border: none;
}

input {
  background: rgba(0, 0, 0, 0.6);
  color: #00eaff;
}

button {
  font-weight: bold;
  background: linear-gradient(135deg, #00eaff, #0077ff);
  cursor: pointer;
}

button:hover {
  opacity: 0.9;
}

#status {
  margin-top: 12px;
  padding: 8px;
  text-align: center;
  font-weight: bold;
  background: rgba(0, 0, 0, 0.5);
  color: #00eaff;
}
</style>
</head>

<body>

<!-- Back Button -->
<a href="trees.html" class="back-btn">‚Üê</a>

<!-- Header -->
<header>
  <div class="title">AVL Tree</div>
  <div class="subtitle">Self-balancing binary search tree visualization</div>
</header>

<!-- Control Panel -->
<div id="panel">
  <input id="valueInput" placeholder="Enter value" />
  <button onclick="insertAVL()">Insert</button>
  <button onclick="deleteAVL()">Delete</button>
  <button onclick="searchAVL()">Search</button>
  <button onclick="resetTree()">Reset</button>
  <div id="status">Status: Ready</div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
/* ---------- SCENE ---------- */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.set(0, 14, 26);
camera.lookAt(0, 6, 0);

/* ---------- RENDERER ---------- */
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.domElement.style.position = "fixed";
renderer.domElement.style.top = "0";
renderer.domElement.style.left = "0";
renderer.domElement.style.zIndex = "1";
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff, 0.9));
scene.add(new THREE.DirectionalLight(0xffffff, 1));

/* ---------- AVL NODE ---------- */
class Node {
  constructor(val) {
    this.val = val;
    this.left = null;
    this.right = null;
    this.height = 1;
    this.mesh = null;
  }
}

let root = null;
const group = new THREE.Group();
scene.add(group);

/* ---------- STATUS ---------- */
function status(msg, color = "#00eaff") {
  const s = document.getElementById("status");
  s.innerText = msg;
  s.style.color = color;
}

/* ---------- BIG LABEL (UPDATED) ---------- */
function createLabel(text) {
  const canvas = document.createElement("canvas");
  canvas.width = 512;
  canvas.height = 512;
  const ctx = canvas.getContext("2d");

  ctx.fillStyle = "#ffffff";
  ctx.font = "bold 150px Arial";   // üî• BIG NUMBER
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(text, 256, 256);

  const texture = new THREE.CanvasTexture(canvas);
  const sprite = new THREE.Sprite(
    new THREE.SpriteMaterial({
      map: texture,
      transparent: true,
      depthTest: false,
    })
  );

  sprite.scale.set(2.2, 2.2, 1);  // üî• BIG LABEL
  return sprite;
}

/* ---------- BIG NODE ---------- */
function createNodeMesh(val) {
  const node = new THREE.Mesh(
    new THREE.SphereGeometry(1.3, 42, 42), // üî• BIG NODE
    new THREE.MeshStandardMaterial({ color: 0x0077ff })
  );
  node.add(createLabel(val.toString()));
  return node;
}

/* ---------- HEIGHT & BALANCE ---------- */
const h = (n) => (n ? n.height : 0);
const balance = (n) => (n ? h(n.left) - h(n.right) : 0);

/* ---------- ROTATIONS ---------- */
function rightRotate(y) {
  const x = y.left;
  const T2 = x.right;
  x.right = y;
  y.left = T2;
  y.height = 1 + Math.max(h(y.left), h(y.right));
  x.height = 1 + Math.max(h(x.left), h(x.right));
  return x;
}

function leftRotate(x) {
  const y = x.right;
  const T2 = y.left;
  y.left = x;
  x.right = T2;
  x.height = 1 + Math.max(h(x.left), h(x.right));
  y.height = 1 + Math.max(h(y.left), h(y.right));
  return y;
}

/* ---------- INSERT ---------- */
function insert(node, val) {
  if (!node) return new Node(val);
  if (val < node.val) node.left = insert(node.left, val);
  else if (val > node.val) node.right = insert(node.right, val);
  else return node;

  node.height = 1 + Math.max(h(node.left), h(node.right));
  const b = balance(node);

  if (b > 1 && val < node.left.val) return rightRotate(node);
  if (b < -1 && val > node.right.val) return leftRotate(node);
  if (b > 1 && val > node.left.val) {
    node.left = leftRotate(node.left);
    return rightRotate(node);
  }
  if (b < -1 && val < node.right.val) {
    node.right = rightRotate(node.right);
    return leftRotate(node);
  }
  return node;
}

/* ---------- DRAW TREE ---------- */
function drawTree() {
  group.clear();
  if (!root) return;

  const q = [[root, 0, 0]];
  const pos = new Map();

  while (q.length) {
    const [n, d, x] = q.shift();
    pos.set(n, { x, y: 7 - d * 2.8 });
    if (n.left) q.push([n.left, d + 1, x - 6 / (d + 2)]);
    if (n.right) q.push([n.right, d + 1, x + 6 / (d + 2)]);
  }

  function render(n) {
    if (!n) return;
    const p = pos.get(n);
    n.mesh = createNodeMesh(n.val);
    n.mesh.position.set(p.x, p.y, 0);
    group.add(n.mesh);

    if (n.left) {
      const lp = pos.get(n.left);
      group.add(new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(p.x, p.y, 0),
          new THREE.Vector3(lp.x, lp.y, 0),
        ]),
        new THREE.LineBasicMaterial({ color: 0xffffff })
      ));
    }

    if (n.right) {
      const rp = pos.get(n.right);
      group.add(new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(p.x, p.y, 0),
          new THREE.Vector3(rp.x, rp.y, 0),
        ]),
        new THREE.LineBasicMaterial({ color: 0xffffff })
      ));
    }

    render(n.left);
    render(n.right);
  }

  render(root);
}

/* ---------- UI ACTIONS ---------- */
function insertAVL() {
  const v = parseInt(valueInput.value);
  if (isNaN(v)) return;
  root = insert(root, v);
  drawTree();
  status("Inserted " + v);
}

function deleteAVL() {
  const v = parseInt(valueInput.value);
  if (isNaN(v)) return;
  root = deleteNode(root, v);
  drawTree();
  status("Deleted " + v, "#ff4444");
}

function searchAVL() {
  const v = parseInt(valueInput.value);
  if (isNaN(v)) return;
  drawTree();
  let n = root;
  while (n) {
    n.mesh.material.color.set(0xffaa00);
    if (n.val === v) {
      n.mesh.material.color.set(0x00ff00);
      status("Found " + v, "#00ff00");
      return;
    }
    n = v < n.val ? n.left : n.right;
  }
  status("Not Found", "#ff4444");
}

function resetTree() {
  root = null;
  group.clear();
  status("Tree Reset");
}

/* ---------- RENDER ---------- */
function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
