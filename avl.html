<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>AVL Tree Visualization</title>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: radial-gradient(circle at top, #1a1a1a, #000);
        font-family: "Segoe UI", sans-serif;
      }

      .back-btn {
        position: fixed;
        top: 18px;
        left: 18px;
        font-size: 34px;
        color: #00eaff;
        text-decoration: none;
        font-weight: bold;
        padding: 6px 12px;
        border-radius: 50%;
        z-index: 100;
      }
      .back-btn:hover {
        background: rgba(0, 234, 255, 0.15);
      }

      header {
        position: fixed;
        top: 0;
        width: 100%;
        height: 90px;
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(10px);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 50;
      }
      header .title {
        font-size: 28px;
        font-weight: 700;
        color: #00eaff;
      }
      header .subtitle {
        font-size: 14px;
        color: #b5f7ff;
        margin-top: 4px;
      }

      #panel {
        position: fixed;
        top: 120px;
        left: 20px;
        width: 280px;
        background: rgba(255, 255, 255, 0.08);
        backdrop-filter: blur(10px);
        border-radius: 14px;
        padding: 16px;
        color: #fff;
        z-index: 40;
        box-shadow: 0 0 30px rgba(0, 234, 255, 0.15);
      }

      input,
      button {
        width: 100%;
        margin-top: 8px;
        padding: 8px;
        border-radius: 8px;
        border: none;
      }
      input {
        background: rgba(0, 0, 0, 0.6);
        color: #00eaff;
      }
      button {
        font-weight: bold;
        background: linear-gradient(135deg, #00eaff, #0077ff);
        cursor: pointer;
      }
      button:hover {
        opacity: 0.9;
      }

      #status {
        margin-top: 12px;
        padding: 8px;
        text-align: center;
        font-weight: bold;
        background: rgba(0, 0, 0, 0.5);
        color: #00eaff;
      }
    </style>
  </head>

  <body>
    <a href="trees.html" class="back-btn">←</a>

    <header>
      <div class="title">AVL Tree</div>
      <div class="subtitle">
        Self-balancing binary search tree visualization
      </div>
    </header>

    <div id="panel">
      <input id="valueInput" placeholder="Enter value" />
      <button onclick="insertAVL()">Insert</button>
      <button onclick="deleteAVL()">Delete</button>
      <button onclick="searchAVL()">Search</button>
      <button onclick="resetTree()">Reset</button>
      <div id="status">Status: Ready</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

    <script>
      /* ---------- SCENE ---------- */
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x111111);

      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        1000,
      );
      camera.position.set(0, 14, 26);
      camera.lookAt(0, 6, 0);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.domElement.style.position = "fixed";
      renderer.domElement.style.top = "0";
      renderer.domElement.style.left = "0";
      renderer.domElement.style.zIndex = "1";
      document.body.appendChild(renderer.domElement);

      scene.add(new THREE.AmbientLight(0xffffff, 0.9));
      scene.add(new THREE.DirectionalLight(0xffffff, 1));

      class Node {
        constructor(val) {
          this.val = val;
          this.left = null;
          this.right = null;
          this.height = 1;
          this.mesh = null;
        }
      }

      let root = null;
      const group = new THREE.Group();
      scene.add(group);

      const h = (n) => (n ? n.height : 0);
      const balance = (n) => (n ? h(n.left) - h(n.right) : 0);

      /* ROTATIONS */
      function rightRotate(y) {
        const x = y.left;
        const T2 = x.right;
        x.right = y;
        y.left = T2;
        y.height = 1 + Math.max(h(y.left), h(y.right));
        x.height = 1 + Math.max(h(x.left), h(x.right));
        return x;
      }

      function leftRotate(x) {
        const y = x.right;
        const T2 = y.left;
        y.left = x;
        x.right = T2;
        x.height = 1 + Math.max(h(x.left), h(x.right));
        y.height = 1 + Math.max(h(y.left), h(y.right));
        return y;
      }

      /* INSERT */
      function insert(node, val) {
        if (!node) return new Node(val);
        if (val < node.val) node.left = insert(node.left, val);
        else if (val > node.val) node.right = insert(node.right, val);
        else return node;

        node.height = 1 + Math.max(h(node.left), h(node.right));
        const b = balance(node);

        if (b > 1 && val < node.left.val) return rightRotate(node);
        if (b < -1 && val > node.right.val) return leftRotate(node);
        if (b > 1 && val > node.left.val) {
          node.left = leftRotate(node.left);
          return rightRotate(node);
        }
        if (b < -1 && val < node.right.val) {
          node.right = rightRotate(node.right);
          return leftRotate(node);
        }
        return node;
      }
      /* ===== AVL DELETE (FIX) ===== */
      function minValueNode(node) {
        let current = node;
        while (current.left) current = current.left;
        return current;
      }

      function deleteNode(root, key) {
        if (!root) return root;

        if (key < root.val) root.left = deleteNode(root.left, key);
        else if (key > root.val) root.right = deleteNode(root.right, key);
        else {
          // node with 1 or 0 child
          if (!root.left || !root.right) {
            const temp = root.left ? root.left : root.right;
            if (!temp) return null;
            else root = temp;
          } else {
            // node with 2 children
            const temp = minValueNode(root.right);
            root.val = temp.val;
            root.right = deleteNode(root.right, temp.val);
          }
        }

        if (!root) return root;

        root.height = 1 + Math.max(h(root.left), h(root.right));
        const b = balance(root);

        // rebalance
        if (b > 1 && balance(root.left) >= 0) return rightRotate(root);
        if (b > 1 && balance(root.left) < 0) {
          root.left = leftRotate(root.left);
          return rightRotate(root);
        }
        if (b < -1 && balance(root.right) <= 0) return leftRotate(root);
        if (b < -1 && balance(root.right) > 0) {
          root.right = rightRotate(root.right);
          return leftRotate(root);
        }

        return root;
      }

      /* ✅ AVL DELETE (ADDED) */
      function minValueNode(node) {
        let current = node;
        while (current.left) current = current.left;
        return current;
      }

      function deleteNode(root, key) {
        if (!root) return root;

        if (key < root.val) root.left = deleteNode(root.left, key);
        else if (key > root.val) root.right = deleteNode(root.right, key);
        else {
          if (!root.left || !root.right) {
            const temp = root.left ? root.left : root.right;
            if (!temp) return null;
            else root = temp;
          } else {
            const temp = minValueNode(root.right);
            root.val = temp.val;
            root.right = deleteNode(root.right, temp.val);
          }
        }

        root.height = 1 + Math.max(h(root.left), h(root.right));
        const b = balance(root);

        if (b > 1 && balance(root.left) >= 0) return rightRotate(root);
        if (b > 1 && balance(root.left) < 0) {
          root.left = leftRotate(root.left);
          return rightRotate(root);
        }
        if (b < -1 && balance(root.right) <= 0) return leftRotate(root);
        if (b < -1 && balance(root.right) > 0) {
          root.right = rightRotate(root.right);
          return leftRotate(root);
        }
        return root;
      }

      /* UI */
      function insertAVL() {
        const v = parseInt(valueInput.value);
        if (isNaN(v)) return;
        root = insert(root, v);
        drawTree();
      }

      function deleteAVL() {
        const v = parseInt(valueInput.value);
        if (isNaN(v)) return;
        root = deleteNode(root, v);
        drawTree();
      }

      /* DRAW + RENDER (unchanged) */
      function drawTree() {
        /* your existing drawTree here */
      }
      function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
      }
      animate();
    </script>
  </body>
</html>
