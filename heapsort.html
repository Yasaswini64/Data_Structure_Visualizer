<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Heap Tree ‚Äì Min & Max Heap (Corrected)</title>

    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: radial-gradient(circle at top, #1a1a1a, #000);
        font-family: "Segoe UI", sans-serif;
      }
      header {
        position: absolute;
        top: 0;
        width: 100%;
        text-align: center;
        padding: 14px;
        font-size: 26px;
        font-weight: 700;
        color: #00eaff;
        background: rgba(0, 0, 0, 0.5);
        z-index: 20;
      }
      #panel {
        position: absolute;
        top: 80px;
        left: 20px;
        width: 280px;
        background: rgba(255, 255, 255, 0.08);
        backdrop-filter: blur(10px);
        border-radius: 14px;
        padding: 16px;
        color: #fff;
        z-index: 10;
      }
      input,
      button,
      select {
        width: 100%;
        margin-top: 8px;
        padding: 8px;
        border-radius: 8px;
        border: none;
      }
      input,
      select {
        background: rgba(0, 0, 0, 0.6);
        color: #00eaff;
      }
      button {
        font-weight: bold;
        background: linear-gradient(135deg, #00eaff, #0077ff);
        cursor: pointer;
      }
      #status {
        margin-top: 12px;
        padding: 8px;
        text-align: center;
        font-weight: bold;
        background: rgba(0, 0, 0, 0.5);
        color: #00eaff;
      }
    </style>
  </head>

  <body>
    <header>HEAP SORT ‚Äì TREE (MIN & MAX HEAP)</header>

    <div id="panel">
      <input id="arrayInput" value="10,5,3,2,8,7,6" />

      <select id="heapType">
        <option value="max">Min Heap</option>
        <option value="min">Max Heap</option>
      </select>

      <button onclick="generate()">Generate Heap</button>
      <button onclick="start()">‚ñ∂ Start Heap Sort</button>
      <button onclick="pause()">‚è∏ Pause</button>
      <button onclick="reset()">üîÑ Reset</button>

      <label>Speed</label>
      <input type="range" id="speed" min="400" max="2000" value="900" />

      <div id="status">Status: Ready</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

    <script>
      /* ---------- SCENE ---------- */
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x111111);

      /* ---------- CAMERA ---------- */
      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 12, 22);
      camera.lookAt(0, 4, 0);

      /* ---------- RENDERER ---------- */
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      /* ---------- LIGHT ---------- */
      scene.add(new THREE.AmbientLight(0xffffff, 0.9));
      scene.add(new THREE.DirectionalLight(0xffffff, 1));

      /* ---------- DATA ---------- */
      let values = [],
        nodes = [],
        steps = [],
        timer = null;
      const group = new THREE.Group();
      scene.add(group);

      /* ---------- STATUS ---------- */
      function status(msg, color = "#00eaff") {
        const s = document.getElementById("status");
        s.innerText = msg;
        s.style.color = color;
      }

      /* ---------- LABEL ---------- */
      function createLabel(text) {
        const canvas = document.createElement("canvas");
        canvas.width = 256;
        canvas.height = 256;
        const ctx = canvas.getContext("2d");

        ctx.fillStyle = "#ffffff";
        ctx.font = "bold 90px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, 128, 128);

        const texture = new THREE.CanvasTexture(canvas);

        const sprite = new THREE.Sprite(
          new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            depthTest: false,
          })
        );
        sprite.scale.set(1.3, 1.3, 1);
        return sprite;
      }

      /* ---------- TREE POSITION ---------- */
      function getPos(i) {
        const level = Math.floor(Math.log2(i + 1));
        const offset = i - (2 ** level - 1);
        return new THREE.Vector3(
          (offset - (2 ** level - 1) / 2) * 3,
          6 - level * 2.7,
          0
        );
      }

      /* ---------- DRAW TREE ---------- */
      function drawTree() {
        group.clear();
        nodes = [];

        values.forEach((val, i) => {
          const node = new THREE.Mesh(
            new THREE.SphereGeometry(0.85, 32, 32),
            new THREE.MeshStandardMaterial({ color: 0x0077ff })
          );
          node.position.copy(getPos(i));

          const label = createLabel(val.toString());
          label.position.set(0, 0, 0);
          node.add(label);

          group.add(node);
          nodes.push(node);

          if (i > 0) {
            const p = Math.floor((i - 1) / 2);
            const geo = new THREE.BufferGeometry().setFromPoints([
              getPos(p),
              getPos(i),
            ]);
            group.add(
              new THREE.Line(
                geo,
                new THREE.LineBasicMaterial({ color: 0xffffff })
              )
            );
          }
        });
      }

      /* ---------- HEAP LOGIC (CORRECT) ---------- */
      function cmp(a, b, type) {
        return type === "max" ? a > b : a < b;
      }

      function heapify(arr, n, i, type) {
        let extreme = i;
        const l = 2 * i + 1;
        const r = 2 * i + 2;

        if (l < n && cmp(arr[l], arr[extreme], type)) extreme = l;
        if (r < n && cmp(arr[r], arr[extreme], type)) extreme = r;

        if (extreme !== i) {
          [arr[i], arr[extreme]] = [arr[extreme], arr[i]];
          steps.push({ a: i, b: extreme });
          heapify(arr, n, extreme, type);
        }
      }

      function heapSortSteps(original) {
        const type = document.getElementById("heapType").value;
        const arr = [...original];
        const n = arr.length;

        // ‚úÖ Build heap (correct)
        for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
          heapify(arr, n, i, type);
        }

        // ‚úÖ Extract elements one by one
        for (let i = n - 1; i > 0; i--) {
          [arr[0], arr[i]] = [arr[i], arr[0]];
          steps.push({ a: 0, b: i, sorted: i });
          heapify(arr, i, 0, type);
        }
      }

      /* ---------- GENERATE ---------- */
      window.generate = function () {
        pause();
        values = document
          .getElementById("arrayInput")
          .value.split(",")
          .map(Number);
        steps = [];
        heapSortSteps(values);
        drawTree();
        status("Heap Generated");
      };

      /* ---------- STEP ---------- */
      function step() {
        if (!steps.length) {
          nodes.forEach((n) => n.material.color.set(0x00ff00));
          status("Sorting Completed", "#00ff00");
          pause();
          return;
        }

        nodes.forEach((n) => n.material.color.set(0x0077ff));
        const s = steps.shift();

        const A = nodes[s.a];
        const B = nodes[s.b];

        const temp = A.position.clone();
        A.position.copy(B.position);
        B.position.copy(temp);

        [nodes[s.a], nodes[s.b]] = [nodes[s.b], nodes[s.a]];

        A.material.color.set(0xff0000);
        B.material.color.set(0xff0000);

        if (s.sorted !== undefined) {
          nodes[s.sorted].material.color.set(0x00ff00);
        }
      }

      /* ---------- CONTROLS ---------- */
      window.start = function () {
        if (timer) return;
        timer = setInterval(step, document.getElementById("speed").value);
      };
      window.pause = function () {
        clearInterval(timer);
        timer = null;
      };
      window.reset = function () {
        pause();
        drawTree();
        status("Ready");
      };

      /* ---------- RENDER ---------- */
      function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      generate();
    </script>
  </body>
</html>