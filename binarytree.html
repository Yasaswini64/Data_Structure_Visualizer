<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Binary Tree Visualization</title>

<style>
body {
  margin: 0;
  overflow: hidden;
  background: radial-gradient(circle at top, #1a1a1a, #000);
  font-family: "Segoe UI", sans-serif;
}

/* BACK */
.back-btn {
  position: fixed;
  top: 18px;
  left: 18px;
  font-size: 34px;
  color: #00eaff;
  text-decoration: none;
  font-weight: bold;
  padding: 6px 12px;
  border-radius: 50%;
  z-index: 100;
}
.back-btn:hover { background: rgba(0,234,255,0.15); }

/* HEADER */
header {
  position: fixed;
  top: 0;
  width: 100%;
  height: 90px;
  background: rgba(0,0,0,0.7);
  backdrop-filter: blur(10px);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 50;
}
header .title { font-size: 28px; font-weight: 700; color: #00eaff; }
header .subtitle { font-size: 14px; color: #b5f7ff; }

/* PANEL */
#panel {
  position: fixed;
  top: 120px;
  left: 20px;
  width: 280px;
  background: rgba(255,255,255,0.08);
  backdrop-filter: blur(10px);
  border-radius: 14px;
  padding: 16px;
  color: #fff;
  z-index: 40;
}

input, button {
  width: 100%;
  margin-top: 8px;
  padding: 8px;
  border-radius: 8px;
  border: none;
}
input { background: rgba(0,0,0,0.6); color: #00eaff; }
button { font-weight: bold; background: linear-gradient(135deg,#00eaff,#0077ff); }
button:hover { opacity: 0.9; }

#status {
  margin-top: 12px;
  padding: 8px;
  text-align: center;
  font-weight: bold;
  background: rgba(0,0,0,0.5);
  color: #00eaff;
}

/* PSEUDO */
#pseudo {
  position: fixed;
  top: 420px;
  left: 20px;
  width: 280px;
  background: rgba(0,0,0,0.85);
  border-radius: 14px;
  padding: 14px;
  font-family: Consolas, monospace;
  font-size: 13px;
  color: #b5f7ff;
  display: none;
  z-index: 40;
}
.line { padding: 4px 6px; border-radius: 6px; }
.line.active {
  background: rgba(0,234,255,0.35);
  color: #00ffff;
}
</style>
</head>

<body>

<a href="trees.html" class="back-btn">←</a>

<header>
  <div class="title">Binary Tree</div>
  <div class="subtitle">Insert • Search • Delete</div>
</header>

<div id="panel">
  <input id="valueInput" placeholder="Enter value" />
  <button onclick="insertNode()">Insert</button>
  <button onclick="searchNode()">Search</button>
  <button onclick="deleteNode()">Delete</button>
  <button onclick="resetTree()">Reset</button>
  <div id="status">Status: Ready</div>
</div>

<div id="pseudo"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
/* THREE */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0,14,26);
camera.lookAt(0,0,0);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.domElement.style.position="fixed";
renderer.domElement.style.top="0";
renderer.domElement.style.left="0";
renderer.domElement.style.zIndex="1";
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff,0.9));
scene.add(new THREE.DirectionalLight(0xffffff,1));

const group = new THREE.Group();
scene.add(group);

let tree = [];
let labels = [];

/* STATUS */
function status(msg,color="#00eaff"){
  const s=document.getElementById("status");
  s.innerText=msg;
  s.style.color=color;
}

/* PSEUDO */
function showPseudo(lines){
  const p=document.getElementById("pseudo");
  p.innerHTML="";
  p.style.display="block";
  lines.forEach((t,i)=>{
    const d=document.createElement("div");
    d.className="line";
    d.id="line"+i;
    d.innerText=t;
    p.appendChild(d);
  });
}
function highlight(i){
  document.querySelectorAll(".line").forEach(l=>l.classList.remove("active"));
  const el=document.getElementById("line"+i);
  if(el) el.classList.add("active");
}
function hidePseudo(){ document.getElementById("pseudo").style.display="none"; }

/* ✅ FIXED LABEL — CENTERED & FIT */
function createLabel(text){
  const c=document.createElement("canvas");
  c.width=256; c.height=256;
  const ctx=c.getContext("2d");

  ctx.clearRect(0,0,256,256);
  ctx.fillStyle="#ffffff";
  ctx.font="bold 96px Arial";        // SAME SIZE
  ctx.textAlign="center";
  ctx.textBaseline="middle";
  ctx.fillText(text,128,128);        // CENTERED

  const sprite=new THREE.Sprite(
    new THREE.SpriteMaterial({
      map:new THREE.CanvasTexture(c),
      transparent:true,
      depthTest:false
    })
  );

  sprite.scale.set(1.6,1.6,1);       // FITS inside sphere
  sprite.position.set(0,0,0.01);     // CENTERED
  labels.push(sprite);
  return sprite;
}

/* POSITION */
function getPos(i){
  const lvl=Math.floor(Math.log2(i+1));
  const off=i-(2**lvl-1);
  return new THREE.Vector3(
    (off-(2**lvl-1)/2)*3.8,
    8-lvl*3,
    0
  );
}

/* DRAW */
function drawTree(){
  group.clear(); labels=[];
  tree.forEach((v,i)=>{
    const n=new THREE.Mesh(
      new THREE.SphereGeometry(1.2,32,32),
      new THREE.MeshStandardMaterial({color:0x0077ff})
    );
    n.position.copy(getPos(i));
    n.add(createLabel(v));
    group.add(n);

    if(i>0){
      const p=Math.floor((i-1)/2);
      group.add(new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([getPos(p),getPos(i)]),
        new THREE.LineBasicMaterial({color:0xffffff})
      ));
    }
  });
}

/* INSERT */
async function insertNode(){
  const v=parseInt(valueInput.value);
  if(isNaN(v)) return;

  showPseudo([
    "IF root == NULL",
    "CREATE new node",
    "COMPARE key",
    "MOVE left/right",
    "INSERT at NULL"
  ]);

  highlight(0); await delay();
  highlight(1); await delay();
  tree.push(v);
  drawTree();
  highlight(4); await delay();

  status("Inserted "+v);
  hidePseudo();
}

/* SEARCH */
async function searchNode(){
  const v=parseInt(valueInput.value);
  if(isNaN(v)) return;

  showPseudo([
    "IF root == NULL",
    "COMPARE key",
    "MOVE left/right",
    "FOUND / NOT FOUND"
  ]);

  let found=false;
  for(let i=0;i<tree.length;i++){
    highlight(1); await delay();
    if(tree[i]===v){ found=true; break; }
  }

  highlight(3); await delay();
  status(found?`Found ${v}`:"Not Found",found?"#00ff00":"#ff4444");
  hidePseudo();
}

/* DELETE */
async function deleteNode(){
  const v=parseInt(valueInput.value);
  if(isNaN(v)) return;

  showPseudo([
    "SEARCH node",
    "CHECK children",
    "REPLACE node",
    "DELETE"
  ]);

  const i=tree.indexOf(v);
  if(i===-1){ status("Not Found","#ff4444"); hidePseudo(); return; }

  highlight(0); await delay();
  highlight(2); await delay();
  tree[i]=tree[tree.length-1];
  tree.pop();
  drawTree();
  highlight(3); await delay();

  status("Deleted "+v,"#ff4444");
  hidePseudo();
}

/* RESET */
function resetTree(){
  tree=[];
  group.clear();
  hidePseudo();
  status("Tree Reset");
}

/* UTIL */
function delay(){ return new Promise(r=>setTimeout(r,800)); }

/* RENDER */
function animate(){
  requestAnimationFrame(animate);
  labels.forEach(l=>l.lookAt(camera.position));
  renderer.render(scene,camera);
}
animate();
</script>

</body>
</html>